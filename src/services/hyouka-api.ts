import BaseClass from './BaseClient';

/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface IEpisodesService {
    get(movieId: number): Promise<EpisodesEvelope | null>;
    create(movieId: number, command: Command): Promise<EpisodeEnvelope | null>;
    delete(movieId: number, id: number): Promise<Unit>;
}

export class EpisodesService extends BaseClass implements IEpisodesService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    get(movieId: number): Promise<EpisodesEvelope | null> {
        let url_ = this.baseUrl + "/api/movies/{movieId}/episodes";
        if (movieId === undefined || movieId === null)
            throw new Error("The parameter 'movieId' must be defined.");
        url_ = url_.replace("{movieId}", encodeURIComponent("" + movieId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<EpisodesEvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EpisodesEvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EpisodesEvelope | null>(<any>null);
    }

    create(movieId: number, command: Command): Promise<EpisodeEnvelope | null> {
        let url_ = this.baseUrl + "/api/movies/{movieId}/episodes";
        if (movieId === undefined || movieId === null)
            throw new Error("The parameter 'movieId' must be defined.");
        url_ = url_.replace("{movieId}", encodeURIComponent("" + movieId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<EpisodeEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EpisodeEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EpisodeEnvelope | null>(<any>null);
    }

    delete(movieId: number, id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/movies/{movieId}/episodes/{id}";
        if (movieId === undefined || movieId === null)
            throw new Error("The parameter 'movieId' must be defined.");
        url_ = url_.replace("{movieId}", encodeURIComponent("" + movieId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Unit.fromJS(resultData200, _mappings) : new Unit();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IUserService {
    login(command: Command2): Promise<UserEnvelope | null>;
    register(command: Command3): Promise<UserEnvelope | null>;
}

export class UserService extends BaseClass implements IUserService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    login(command: Command2): Promise<UserEnvelope | null> {
        let url_ = this.baseUrl + "/api/user/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLogin(_response));
        });
    }

    protected processLogin(response: Response): Promise<UserEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEnvelope | null>(<any>null);
    }

    register(command: Command3): Promise<UserEnvelope | null> {
        let url_ = this.baseUrl + "/api/user/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRegister(_response));
        });
    }

    protected processRegister(response: Response): Promise<UserEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEnvelope | null>(<any>null);
    }
}

export interface IMoviesService {
    get(tag?: string | null | undefined): Promise<MoviesEnvelope | null>;
    create(command: Command4): Promise<MovieEnvelope | null>;
    get2(id: number): Promise<MovieEnvelope | null>;
    edit(id: number, command: Command5): Promise<MovieEnvelope | null>;
    delete(id: number): Promise<Unit>;
}

export class MoviesService extends BaseClass implements IMoviesService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    get(tag?: string | null | undefined): Promise<MoviesEnvelope | null> {
        let url_ = this.baseUrl + "/api/movies?";
        if (tag !== undefined)
            url_ += "tag=" + encodeURIComponent("" + tag) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<MoviesEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MoviesEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MoviesEnvelope | null>(<any>null);
    }

    create(command: Command4): Promise<MovieEnvelope | null> {
        let url_ = this.baseUrl + "/api/movies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<MovieEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MovieEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovieEnvelope | null>(<any>null);
    }

    get2(id: number): Promise<MovieEnvelope | null> {
        let url_ = this.baseUrl + "/api/movies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet2(_response));
        });
    }

    protected processGet2(response: Response): Promise<MovieEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MovieEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovieEnvelope | null>(<any>null);
    }

    edit(id: number, command: Command5): Promise<MovieEnvelope | null> {
        let url_ = this.baseUrl + "/api/movies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEdit(_response));
        });
    }

    protected processEdit(response: Response): Promise<MovieEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MovieEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MovieEnvelope | null>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/movies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<Unit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Unit.fromJS(resultData200, _mappings) : new Unit();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IGenresService {
    get(): Promise<GenresEnvelope | null>;
    post(command: Command6): Promise<GenreEnvelope | null>;
}

export class GenresService extends BaseClass implements IGenresService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    get(): Promise<GenresEnvelope | null> {
        let url_ = this.baseUrl + "/api/genres";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<GenresEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GenresEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GenresEnvelope | null>(<any>null);
    }

    post(command: Command6): Promise<GenreEnvelope | null> {
        let url_ = this.baseUrl + "/api/genres";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPost(_response));
        });
    }

    protected processPost(response: Response): Promise<GenreEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GenreEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GenreEnvelope | null>(<any>null);
    }
}

export interface IFileService {
    download(action?: string | null | undefined, path?: string | null | undefined): Promise<FileResponse | null>;
    navigate(command: ActionCommand): Promise<FileResultEnvelope | null>;
    fileAction(command: ActionCommand): Promise<ActionResultEnvelope | null>;
    getContent(command: ActionCommand): Promise<ContentEnvelope | null>;
    upload(destination?: string | null | undefined, files?: FileParameter[] | null | undefined): Promise<ActionResultEnvelope | null>;
}

export class FileService extends BaseClass implements IFileService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    download(action?: string | null | undefined, path?: string | null | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/file?";
        if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&"; 
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDownload(_response));
        });
    }

    protected processDownload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    navigate(command: ActionCommand): Promise<FileResultEnvelope | null> {
        let url_ = this.baseUrl + "/api/file/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processNavigate(_response));
        });
    }

    protected processNavigate(response: Response): Promise<FileResultEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileResultEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResultEnvelope | null>(<any>null);
    }

    fileAction(command: ActionCommand): Promise<ActionResultEnvelope | null> {
        let url_ = this.baseUrl + "/api/file/command";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processFileAction(_response));
        });
    }

    protected processFileAction(response: Response): Promise<ActionResultEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActionResultEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActionResultEnvelope | null>(<any>null);
    }

    getContent(command: ActionCommand): Promise<ContentEnvelope | null> {
        let url_ = this.baseUrl + "/api/file/content";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetContent(_response));
        });
    }

    protected processGetContent(response: Response): Promise<ContentEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentEnvelope | null>(<any>null);
    }

    upload(destination?: string | null | undefined, files?: FileParameter[] | null | undefined): Promise<ActionResultEnvelope | null> {
        let url_ = this.baseUrl + "/api/file/upload?";
        if (destination !== undefined)
            url_ += "Destination=" + encodeURIComponent("" + destination) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("Files", item_.data, item_.fileName ? item_.fileName : "Files") );

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpload(_response));
        });
    }

    protected processUpload(response: Response): Promise<ActionResultEnvelope | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActionResultEnvelope.fromJS(resultData200, _mappings) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActionResultEnvelope | null>(<any>null);
    }
}

export class EpisodesEvelope implements IEpisodesEvelope {
    episodes?: Episode[] | null;
    count!: number;

    constructor(data?: IEpisodesEvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            if (data["episodes"] && data["episodes"].constructor === Array) {
                this.episodes = [];
                for (let item of data["episodes"])
                    this.episodes.push(Episode.fromJS(item, _mappings));
            }
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EpisodesEvelope {
        data = typeof data === 'object' ? data : {};
        return createInstance<EpisodesEvelope>(data, _mappings, EpisodesEvelope);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.episodes && this.episodes.constructor === Array) {
            data["episodes"] = [];
            for (let item of this.episodes)
                data["episodes"].push(item.toJSON());
        }
        data["count"] = this.count !== undefined ? this.count : <any>null;
        return data; 
    }
}

export interface IEpisodesEvelope {
    episodes?: Episode[] | null;
    count: number;
}

export class Episode implements IEpisode {
    episodeId!: number;
    name?: string | null;
    number?: string | null;
    file?: string | null;
    movieId!: number;
    movie?: Movie | null;

    constructor(data?: IEpisode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.episodeId = data["episodeId"] !== undefined ? data["episodeId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.file = data["file"] !== undefined ? data["file"] : <any>null;
            this.movieId = data["movieId"] !== undefined ? data["movieId"] : <any>null;
            this.movie = data["movie"] ? Movie.fromJS(data["movie"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Episode {
        data = typeof data === 'object' ? data : {};
        return createInstance<Episode>(data, _mappings, Episode);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["episodeId"] = this.episodeId !== undefined ? this.episodeId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["movieId"] = this.movieId !== undefined ? this.movieId : <any>null;
        data["movie"] = this.movie ? this.movie.toJSON() : <any>null;
        return data; 
    }
}

export interface IEpisode {
    episodeId: number;
    name?: string | null;
    number?: string | null;
    file?: string | null;
    movieId: number;
    movie?: Movie | null;
}

export class Movie implements IMovie {
    movieId!: number;
    title?: string | null;
    description?: string | null;
    image?: string | null;
    releaseDate!: string;
    genreList?: string[] | null;
    episodeCount!: number;

    constructor(data?: IMovie) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.movieId = data["movieId"] !== undefined ? data["movieId"] : <any>null;
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.image = data["image"] !== undefined ? data["image"] : <any>null;
            this.releaseDate = data["releaseDate"] !== undefined ? data["releaseDate"] : <any>null;
            if (data["genreList"] && data["genreList"].constructor === Array) {
                this.genreList = [];
                for (let item of data["genreList"])
                    this.genreList.push(item);
            }
            this.episodeCount = data["episodeCount"] !== undefined ? data["episodeCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Movie {
        data = typeof data === 'object' ? data : {};
        return createInstance<Movie>(data, _mappings, Movie);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movieId"] = this.movieId !== undefined ? this.movieId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["releaseDate"] = this.releaseDate !== undefined ? this.releaseDate : <any>null;
        if (this.genreList && this.genreList.constructor === Array) {
            data["genreList"] = [];
            for (let item of this.genreList)
                data["genreList"].push(item);
        }
        data["episodeCount"] = this.episodeCount !== undefined ? this.episodeCount : <any>null;
        return data; 
    }
}

export interface IMovie {
    movieId: number;
    title?: string | null;
    description?: string | null;
    image?: string | null;
    releaseDate: string;
    genreList?: string[] | null;
    episodeCount: number;
}

export class EpisodeEnvelope implements IEpisodeEnvelope {
    episode?: Episode | null;

    constructor(data?: IEpisodeEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.episode = data["episode"] ? Episode.fromJS(data["episode"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EpisodeEnvelope {
        data = typeof data === 'object' ? data : {};
        return createInstance<EpisodeEnvelope>(data, _mappings, EpisodeEnvelope);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["episode"] = this.episode ? this.episode.toJSON() : <any>null;
        return data; 
    }
}

export interface IEpisodeEnvelope {
    episode?: Episode | null;
}

export class Command implements ICommand {
    episode?: EpisodeData | null;
    movieId!: number;

    constructor(data?: ICommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.episode = data["episode"] ? EpisodeData.fromJS(data["episode"], _mappings) : <any>null;
            this.movieId = data["movieId"] !== undefined ? data["movieId"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Command {
        data = typeof data === 'object' ? data : {};
        return createInstance<Command>(data, _mappings, Command);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["episode"] = this.episode ? this.episode.toJSON() : <any>null;
        data["movieId"] = this.movieId !== undefined ? this.movieId : <any>null;
        return data; 
    }
}

export interface ICommand {
    episode?: EpisodeData | null;
    movieId: number;
}

export class EpisodeData implements IEpisodeData {
    name?: string | null;
    number?: string | null;
    file?: string | null;

    constructor(data?: IEpisodeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.file = data["file"] !== undefined ? data["file"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EpisodeData {
        data = typeof data === 'object' ? data : {};
        return createInstance<EpisodeData>(data, _mappings, EpisodeData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["file"] = this.file !== undefined ? this.file : <any>null;
        return data; 
    }
}

export interface IEpisodeData {
    name?: string | null;
    number?: string | null;
    file?: string | null;
}

export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
        }
    }

    static fromJS(data: any, _mappings?: any): Unit {
        data = typeof data === 'object' ? data : {};
        return createInstance<Unit>(data, _mappings, Unit);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IUnit {
}

export class UserEnvelope implements IUserEnvelope {
    user?: User | null;

    constructor(data?: IUserEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.user = data["user"] ? User.fromJS(data["user"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UserEnvelope {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserEnvelope>(data, _mappings, UserEnvelope);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data; 
    }
}

export interface IUserEnvelope {
    user?: User | null;
}

export class User implements IUser {
    username?: string | null;
    email?: string | null;
    img?: string | null;
    token?: string | null;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.img = data["img"] !== undefined ? data["img"] : <any>null;
            this.token = data["token"] !== undefined ? data["token"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): User {
        data = typeof data === 'object' ? data : {};
        return createInstance<User>(data, _mappings, User);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["img"] = this.img !== undefined ? this.img : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data; 
    }
}

export interface IUser {
    username?: string | null;
    email?: string | null;
    img?: string | null;
    token?: string | null;
}

export class Command2 implements ICommand2 {
    user?: LoginData | null;

    constructor(data?: ICommand2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.user = data["user"] ? LoginData.fromJS(data["user"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Command2 {
        data = typeof data === 'object' ? data : {};
        return createInstance<Command2>(data, _mappings, Command2);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data; 
    }
}

export interface ICommand2 {
    user?: LoginData | null;
}

export class LoginData implements ILoginData {
    username?: string | null;
    password?: string | null;

    constructor(data?: ILoginData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): LoginData {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginData>(data, _mappings, LoginData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface ILoginData {
    username?: string | null;
    password?: string | null;
}

export class Command3 implements ICommand3 {
    user?: UserData | null;

    constructor(data?: ICommand3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.user = data["user"] ? UserData.fromJS(data["user"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Command3 {
        data = typeof data === 'object' ? data : {};
        return createInstance<Command3>(data, _mappings, Command3);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data; 
    }
}

export interface ICommand3 {
    user?: UserData | null;
}

export class UserData implements IUserData {
    username?: string | null;
    email?: string | null;
    password?: string | null;

    constructor(data?: IUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): UserData {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserData>(data, _mappings, UserData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IUserData {
    username?: string | null;
    email?: string | null;
    password?: string | null;
}

export class MoviesEnvelope implements IMoviesEnvelope {
    movies?: Movie[] | null;
    count!: number;

    constructor(data?: IMoviesEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            if (data["movies"] && data["movies"].constructor === Array) {
                this.movies = [];
                for (let item of data["movies"])
                    this.movies.push(Movie.fromJS(item, _mappings));
            }
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MoviesEnvelope {
        data = typeof data === 'object' ? data : {};
        return createInstance<MoviesEnvelope>(data, _mappings, MoviesEnvelope);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.movies && this.movies.constructor === Array) {
            data["movies"] = [];
            for (let item of this.movies)
                data["movies"].push(item.toJSON());
        }
        data["count"] = this.count !== undefined ? this.count : <any>null;
        return data; 
    }
}

export interface IMoviesEnvelope {
    movies?: Movie[] | null;
    count: number;
}

export class MovieEnvelope implements IMovieEnvelope {
    movie?: Movie | null;

    constructor(data?: IMovieEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.movie = data["movie"] ? Movie.fromJS(data["movie"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MovieEnvelope {
        data = typeof data === 'object' ? data : {};
        return createInstance<MovieEnvelope>(data, _mappings, MovieEnvelope);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movie"] = this.movie ? this.movie.toJSON() : <any>null;
        return data; 
    }
}

export interface IMovieEnvelope {
    movie?: Movie | null;
}

export class Command4 implements ICommand4 {
    movie?: MovieData | null;

    constructor(data?: ICommand4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.movie = data["movie"] ? MovieData.fromJS(data["movie"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Command4 {
        data = typeof data === 'object' ? data : {};
        return createInstance<Command4>(data, _mappings, Command4);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movie"] = this.movie ? this.movie.toJSON() : <any>null;
        return data; 
    }
}

export interface ICommand4 {
    movie?: MovieData | null;
}

export class MovieData implements IMovieData {
    title?: string | null;
    description?: string | null;
    realeaseDate!: string;
    genreList?: number[] | null;
    image?: string | null;

    constructor(data?: IMovieData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.realeaseDate = data["realeaseDate"] !== undefined ? data["realeaseDate"] : <any>null;
            if (data["genreList"] && data["genreList"].constructor === Array) {
                this.genreList = [];
                for (let item of data["genreList"])
                    this.genreList.push(item);
            }
            this.image = data["image"] !== undefined ? data["image"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MovieData {
        data = typeof data === 'object' ? data : {};
        return createInstance<MovieData>(data, _mappings, MovieData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["realeaseDate"] = this.realeaseDate !== undefined ? this.realeaseDate : <any>null;
        if (this.genreList && this.genreList.constructor === Array) {
            data["genreList"] = [];
            for (let item of this.genreList)
                data["genreList"].push(item);
        }
        data["image"] = this.image !== undefined ? this.image : <any>null;
        return data; 
    }
}

export interface IMovieData {
    title?: string | null;
    description?: string | null;
    realeaseDate: string;
    genreList?: number[] | null;
    image?: string | null;
}

export class Command5 implements ICommand5 {
    id!: number;
    movie?: MovieData2 | null;

    constructor(data?: ICommand5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.movie = data["movie"] ? MovieData2.fromJS(data["movie"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Command5 {
        data = typeof data === 'object' ? data : {};
        return createInstance<Command5>(data, _mappings, Command5);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["movie"] = this.movie ? this.movie.toJSON() : <any>null;
        return data; 
    }
}

export interface ICommand5 {
    id: number;
    movie?: MovieData2 | null;
}

export class MovieData2 implements IMovieData2 {
    title?: string | null;
    description?: string | null;
    image?: string | null;
    realeaseDate!: string;

    constructor(data?: IMovieData2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.image = data["image"] !== undefined ? data["image"] : <any>null;
            this.realeaseDate = data["realeaseDate"] !== undefined ? data["realeaseDate"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MovieData2 {
        data = typeof data === 'object' ? data : {};
        return createInstance<MovieData2>(data, _mappings, MovieData2);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["realeaseDate"] = this.realeaseDate !== undefined ? this.realeaseDate : <any>null;
        return data; 
    }
}

export interface IMovieData2 {
    title?: string | null;
    description?: string | null;
    image?: string | null;
    realeaseDate: string;
}

export class GenresEnvelope implements IGenresEnvelope {
    genre?: Genre[] | null;

    constructor(data?: IGenresEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            if (data["genre"] && data["genre"].constructor === Array) {
                this.genre = [];
                for (let item of data["genre"])
                    this.genre.push(Genre.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): GenresEnvelope {
        data = typeof data === 'object' ? data : {};
        return createInstance<GenresEnvelope>(data, _mappings, GenresEnvelope);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.genre && this.genre.constructor === Array) {
            data["genre"] = [];
            for (let item of this.genre)
                data["genre"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGenresEnvelope {
    genre?: Genre[] | null;
}

export class Genre implements IGenre {
    genreId!: number;
    name?: string | null;

    constructor(data?: IGenre) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.genreId = data["genreId"] !== undefined ? data["genreId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Genre {
        data = typeof data === 'object' ? data : {};
        return createInstance<Genre>(data, _mappings, Genre);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["genreId"] = this.genreId !== undefined ? this.genreId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IGenre {
    genreId: number;
    name?: string | null;
}

export class GenreEnvelope implements IGenreEnvelope {
    genre?: Genre | null;

    constructor(data?: IGenreEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.genre = data["genre"] ? Genre.fromJS(data["genre"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): GenreEnvelope {
        data = typeof data === 'object' ? data : {};
        return createInstance<GenreEnvelope>(data, _mappings, GenreEnvelope);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["genre"] = this.genre ? this.genre.toJSON() : <any>null;
        return data; 
    }
}

export interface IGenreEnvelope {
    genre?: Genre | null;
}

export class Command6 implements ICommand6 {
    name?: string | null;

    constructor(data?: ICommand6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Command6 {
        data = typeof data === 'object' ? data : {};
        return createInstance<Command6>(data, _mappings, Command6);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ICommand6 {
    name?: string | null;
}

export class FileResultEnvelope implements IFileResultEnvelope {
    result?: FileData[] | null;

    constructor(data?: IFileResultEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            if (data["result"] && data["result"].constructor === Array) {
                this.result = [];
                for (let item of data["result"])
                    this.result.push(FileData.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): FileResultEnvelope {
        data = typeof data === 'object' ? data : {};
        return createInstance<FileResultEnvelope>(data, _mappings, FileResultEnvelope);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.result && this.result.constructor === Array) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFileResultEnvelope {
    result?: FileData[] | null;
}

export class FileData implements IFileData {
    name?: string | null;
    rights?: string | null;
    size?: string | null;
    date?: string | null;
    type?: string | null;

    constructor(data?: IFileData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.rights = data["rights"] !== undefined ? data["rights"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): FileData {
        data = typeof data === 'object' ? data : {};
        return createInstance<FileData>(data, _mappings, FileData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["rights"] = this.rights !== undefined ? this.rights : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IFileData {
    name?: string | null;
    rights?: string | null;
    size?: string | null;
    date?: string | null;
    type?: string | null;
}

export class ActionCommand implements IActionCommand {
    action?: string | null;
    path?: string | null;
    newPath?: string | null;
    item?: string | null;
    newItemPath?: string | null;
    items?: string[] | null;

    constructor(data?: IActionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.action = data["action"] !== undefined ? data["action"] : <any>null;
            this.path = data["path"] !== undefined ? data["path"] : <any>null;
            this.newPath = data["newPath"] !== undefined ? data["newPath"] : <any>null;
            this.item = data["item"] !== undefined ? data["item"] : <any>null;
            this.newItemPath = data["newItemPath"] !== undefined ? data["newItemPath"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ActionCommand {
        data = typeof data === 'object' ? data : {};
        return createInstance<ActionCommand>(data, _mappings, ActionCommand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action !== undefined ? this.action : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["newPath"] = this.newPath !== undefined ? this.newPath : <any>null;
        data["item"] = this.item !== undefined ? this.item : <any>null;
        data["newItemPath"] = this.newItemPath !== undefined ? this.newItemPath : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        return data; 
    }
}

export interface IActionCommand {
    action?: string | null;
    path?: string | null;
    newPath?: string | null;
    item?: string | null;
    newItemPath?: string | null;
    items?: string[] | null;
}

export class ActionResultEnvelope implements IActionResultEnvelope {
    result?: FileActionResult | null;

    constructor(data?: IActionResultEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.result = data["result"] ? FileActionResult.fromJS(data["result"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ActionResultEnvelope {
        data = typeof data === 'object' ? data : {};
        return createInstance<ActionResultEnvelope>(data, _mappings, ActionResultEnvelope);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>null;
        return data; 
    }
}

export interface IActionResultEnvelope {
    result?: FileActionResult | null;
}

export class FileActionResult implements IFileActionResult {
    success!: boolean;
    error?: any | null;

    constructor(data?: IFileActionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            this.error = data["error"] !== undefined ? data["error"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): FileActionResult {
        data = typeof data === 'object' ? data : {};
        return createInstance<FileActionResult>(data, _mappings, FileActionResult);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        return data; 
    }
}

export interface IFileActionResult {
    success: boolean;
    error?: any | null;
}

export class ContentEnvelope implements IContentEnvelope {
    result?: string | null;

    constructor(data?: IContentEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any, _mappings?: any) {
        if (data) {
            this.result = data["result"] !== undefined ? data["result"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ContentEnvelope {
        data = typeof data === 'object' ? data : {};
        return createInstance<ContentEnvelope>(data, _mappings, ContentEnvelope);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result !== undefined ? this.result : <any>null;
        return data; 
    }
}

export interface IContentEnvelope {
    result?: string | null;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
    if (!mappings)
        mappings = [];
    else {
        let mapping = mappings.filter((m: any) => m.source === data);
        if (mapping.length === 1)
            return <T>mapping[0].target;
    }

    let result: any = new type();
    mappings.push({ source: data, target: result });
    result.init(data, mappings);
    return result;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new SwaggerException(message, status, response, headers, result);
}